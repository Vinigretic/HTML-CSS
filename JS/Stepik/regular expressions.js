//Что такое регулярные выражения?
//
//Регулярное выражение (RegExp - regular expressions) это объект, который может описывать шаблон символов.
//
//Например, если вы ищете в строке подстроку, вы можете описать шаблон того, что вы ищете.
//
//Простой шаблон может состоять даже из одного символа, большие и сложные шаблоны могут использоваться для парсинга,
//проверки формата введенных данных, замены и других различных целей.
//
//Содержание шаблона регулярного выражения состоит из последовательности символов. Большая их часть (все буквы и цифры)
//описывают сами себя - непосредственно указывают свое присутствие. Например, регулярное выражение
//
///hello/
//совпадет со всеми строками, в которых есть слово "hello". Другие символы обозначают не себя, а имеют некоторое модифицирующее
// значение.
//
//Например, выражение
//
///hello$/
//будет соответствовать строкам, которые ЗАКАНЧИВАЮТСЯ на слово "hello". Это обеспечивает метасимвол "$", обозначающий конец
//строки.

//Создание объектов RegExp
//
//Объекты RegExp могут быть созданы с помощью конструктора RegExp(), или с помощью литералов. Но если, например, строковые
//литералы задаются в виде символов, заключенных в кавычки, то литералы регулярных выражений задаются заключенными в пару
//символов слэш  "/". Например, вот так:
//
//var myPattern = /q$/;   //Создание регулярного выражения с помощью литерала
//В данном примере мы создали c помощью литерала новый объект типа RegExp и присвоили его переменной myPattern. Данный шаблон
//соответствует любой строке, заканчивающейся символом q.
//
//
//
//Для создания такого же объекта с помощью конструктора нам нужно написать вот такое выражение:
//
//var myPattern = new RegExp("q$");  //Создание регулярного выражения с помощью конструктора

//Теперь давайте рассмотрим из чего можно составлять регулярные выражения.
//
//Первая группа это конечно же символы. Как мы уже говорили все алфавитные и цифровые символы обозначают сами себя. Также можно
// вводить некоторые не алфавитные символы с помощью последовательностей, начинающихся с обратного слэша.
//
//Цифры и буквы - соответствуют сами себе
//\0 - Символ NUL (Соответствует \u0000 в Unicode)
//\t - Табуляция (\u0009)
//\n - Перевод строки (\u000A)
//\v - Вертикальная табуляция (\u000B)
//\f - Перевод страницы (\u000C)
//\r - Возврат каретки (\u000D)
//\xnn - Символ из набора Latin, задаваемый шестнадцатиричным номером nn
//\unnnn - Символ Unicode,  задаваемый шестнадцатиричным номером nnnn
//\cX - Управляющий символ "Х", например \сJ эквивалентна \n
//
//Также в регулярных выражениях используются следующие символы:
//
//^ $ . * + ? = ! : | \ / ( ) [ ] { }
//В следующих шагах мы более подробно рассмотрим их значение и применение в комбинации с другими символами, однако сейчас
//нужно запомнить, что для определения смысла этих символов буквально, т.е. "самих себя", необходимо перед ними ставить символ
//обратного слэша.
//
//Например, если вы хотите написать регулярное выражение, по которому будет находиться символ обратного слэша, то вы должны в
//ыражение поставить этот символ, предваряемый таким же символом обратного слэша. В результате такое регулярное выражение
//будет выглядеть следующим образом:
//
//  /\\/

//Отдельные символы могут быть объединены в классы. Это обозначается набором символов, заключенных в квадратные скобки.
//Например регулярное выражение
//
///[0123456789]/
//соответствует любой цифре.
//
//Или же можно указав перед набором символов знак "^" определить регулярное выражение, которое будет соответствовать
//любому символу, КРОМЕ тех, которые указаны в скобках - класс с отрицанием. Например выражение
//
///[^0123456789]/
//будет соответствовать любому символу КРОМЕ цифр.
//
//Также в классах можно задавать диапазон с помощью знака дефиса "-", чтобы не перечислять все символы. Например все
//цифры можно обозначить таким выражением:
//
///[0-9]/
//Некоторые классы из наборов символов настолько часто используются, что для них определили специальные обозначения:
//
//[...] - любой из символов, указанных в скобках
//[^...] - любой кроме символов, указанных в скобках
//. (точка) - любой символ кроме перевода строки или другого разделителя строки
//\w - эквивалентно [a-zA-Z0-9_] (Любой текстовый символ ASCII)
//\W - эквивалентно [^a-zA-Z0-9_] (Любой символ кроме текстовых символов ASCII)
//\s - любой пробельный символ из Unicode
//
//\S - любой НЕпробельный символ из Unicode
//\d - эквивалентно [0-9] (любые цифры ASCII)
//\D - эквивалентно [^0-9] (все символы кроме цифр ASCII)
//[\b] - обозначение символа "забой"
//Последовательности таких управляющих символов также можно объединить в класс, например регулярное выражение
//
///[\w\s]/
//соответствует любому пробельному символу или символу ASCII - букве или цифре.

//Описанные выше шаблоны можно использовать не только для описания одиночных комбинаций символов, но и для сколь угодно
//многократных повторений. Это называют "квантификацией".
//
//Для квантификации в регулярных выражениях есть набор специальных комбинаций, заключаемых в фигурные скобки. Эта комбинация
//в фигурных скобках должна следовать сразу за описанным шаблоном. Например комбинация
//
///\d{4}/
//соответствует числу, состоящему из 4-х цифр.
//
//Давайте рассмотрим какие бывают управляющие комбинации для повторений:
//
//{n} - обозначает ровно n экземпляров шаблона
//{n,} - обозначает n или больше экземпляров шаблона
//{n,m} -  обозначает не менее n и не более m экземпляров шаблона
//? -  обозначает ноль или один экземпляр шаблона (эквивалентно выражению {0,1} )
//+ -  обозначает 1 или более экземпляров шаблона (эквивалентно выражению {1,} )
//* -  обозначает ноль или более экземпляров шаблона (эквивалентно выражению {0,} )
//Эти комбинации повторения соответствуют максимально возможному количеству совпадений. Например выражение
//
///х{1,}/
//примененное к строке "ххх" будет соответствовать максимальному количеству совпадений, т.е. всем трем буквам "х",
//встреченным в строке. Это называется "жадным" повторением. ("жадной" квантификацией).
//
//Если же мы хотим ограничить поиск первым же вхождением, то может использовать так называемую "нежадную", или "ленивую"
// квантификацию. Для этого после управляющей комбинации повторений ставится символ "?". Таким образом выражение
//
///х{1,}?/
//будет соответствовать только первому соответствию, т.е. только первой букве "х" в строке.
//
//Важный момент! Признак "ленивости" действует только на тот квантификатор (подшаблон) в шаблоне, после которого стоит,
//все остальные квантификаторы остаются "жадными".

//Синтаксис регулярных выражений содержит специальный символ для определения альтернативы, т.е. можно указать больше
//одного варианта шаблона, соответствие которому будет проверяться.  Для разделения альтернатив используется символ "|" -
//вертикальная черта.
//
//Например, выражение
//
///ma|pa|da/
//будет соответствовать либо строке "ma" либо строке "pa" либо строке "da".
//
//Альтернативы конечно также могут комбинироваться и с классами и с повторениями. Указанный ниже шаблон соответствует
// либо двум цифрам либо двум строчным буквам либо двум заглавным буквам:
//
///\d{2}|[a-z]{2}|[A-Z]{2}/
//Необходимо обратить внимание, что альтернативы обрабатываются слева направо до первого соответствия. После нахождения
//первого соответствия остальные альтернативы будут игнорироваться. На практике это означает что, например,
//шаблон /1|12|123/ примененный к строке "123", будет соответствовать первому символу, хотя в альтернативах есть
//гораздо более полное соответствие.

//Рассмотрим еще одну возможность, которую мы можем использовать в регулярных выражениях - группировку.
//Группировка обозначается заключением подшаблона в круглые скобки ( ). При этом элементы, используемые совместно со
//специальными символами, например |, +, *, ? и другие, будут рассматриваться как одно целое.
//
//Например шаблон
//
///regular(expression)?/
//будет соответствовать слову "regular" за которым следует необязательное слово "expression".
//
//В качестве примера использования подшаблона со специальными символами можно рассмотреть такой:
//Выражение /123+ означает цифры 12, после которых следует любое количество повторения цифры 3, т.е. этому шаблону будут
//соответствовать значения 123, 1233, 12333 и так далее.
//Если же мы заключим 123 в скобки, то + будет относиться ко всей группе, и этому шаблону будут соответствовать значения
// 123, 123123, 123123123 и т.д.

//Еще одна возможность регулярных выражений - указание границы соответствия. Для этого используются якорные выражения.
//
//Часто нам нужно найти слово, находящееся на отдельной строке, или в начале строки. Как вариант, может понадобиться найти
//отдельное слово, однако просто задать шаблон, в котором слово будет обрамлено пробелами мы не можем - в выборку не попадут
//слова с которых начинаются строки, или которыми заканчиваются. Также граница слова может определяться любым знаком
//препинания в тексте и перечислять в шаблоне все возможные комбинации было бы достаточно утомительно. Давайте рассмотрим,
// какие специальные символы используются для определения границ:
//
//^ - соответствует началу строки при многострочном поиске или началу строкового выражения
//$ - соответствует концу строки при многострочном поиске или концу строкового выражения
//\b - соответствует границе слова, т.е. позиции между текстовым (aA-zZ) и не-текстовым символом, либо между текстовым
//символом и началом или концом строки.
//\B - Соответствует позиции, не являющейся границей слов.
//(?=p) - Позитивная опережающая проверка на последующие символы - убеждается в том, что последующие символы соответствуют
//шаблону "р" но не включает их в результат поиска.
//(?!p) - Негативная опережающая проверка на последующие символы - требует чтобы последующие символы НЕ соответствовали
// шаблону "р".

//Ну и последний элемент синтаксиса регулярных выражений - флаги. Флаги задают глобальные правила для всего шаблона и
//указываются не внутри символов слэша, в которые заключен шаблон, а ПОСЛЕ них.
//
//JavaScript поддерживает три варианта флагов:
//i - указывает на то, что поиск по шаблону должен быть не чувствительным к регистру
//g - указывает что поиск должен быть глобальным, т.е. должны быть найдены ВСЕ соответствия в строке
//m - указывает на то, что поиск должен производиться в многострочном режиме.

///\#([a-fA-F]|[0-9]){3,6}/ цвет
///^([0-1]\d|2[0-3])(:[0-5]\d){2}$/ Время в формате HH:MM:SS
///-?\d{1,3}\.\d+/ широта
///^([0-9a-z]([0-9a-z\-])*[0-9a-z]\.)+[a-z]{2,4}$/i Доменное имя
///[A-Z0-9._%+-]+@[A-Z0-9-]+\.[A-Z]{2,4}/igm Адрес электронной почты
///([\d]{2})\.([\d]{2})\.([\d]{4})/Дата в формате DD.MM.YYYY
///^\d{6}$/Почтовый индекс РФ

//В данном уроке сначала мы рассмотрим методы класса String, позволяющие использовать регулярные выражения:
//
//
//
//search(regexp)
//replace(regexp, newString)
//match(regexp)
//split(divider)
//
//
//
//Первый и самый простой это метод search()
//В качестве аргумента мы передаем ему регулярное выражение, а он нам в ответ возвращает номер позиции, с которой найдено
//соответствие шаблону, либо "-1" если соответствие не найдено.
//
//
//
//var myString = "This is just test string";
//result = myString.search(/is/);
//
//
//В указанном примере в переменной result окажется число 2 (отсчет позиций начинается с 0).
//
//
//
//Два важных момента:
//1. Метод search() не поддерживает глобальный поиск (про него чуть позже) и флаг g в составе регулярного выражения будет
//игнорирован.
//
//2.  Если аргумент не является регулярным выражением, то он будет преобразован в него передачей конструктору RegExp.

//Следующий метод, с которым мы познакомимся, это replace()
//
//С его помощью можно выполнить операцию поиска с заменой.
//В качестве аргументов он принимает регулярное выражение и строку замены.
//
//var myString = "This is just test string";
//result = myString.replace(/is/,"as");
//Данный пример заменит первое найденное соответствие шаблону ("is") на подстроку "as", в результате в переменной result
//окажется строка  "Thas is just test string".
//
//
//
//Нужно отметить, что этот метод поддерживает глобальный поиск и при использовании флага "g" поменяет все найденные
//соответствия.
//
//var myString = "This is just test string";
//result = myString.replace(/is/g,"us");
//В этом примере в переменной result окажется строка  "Thus us just test string".
//
//
//
//Еще необходимо отметить, что в качестве второго аргумента метода replace() может использоваться функция, в этом случае мы
//получим возможность динамического изменения строки замены.
//Если в качестве первого аргумента окажется не регулярное выражение, то он будет также как и у метода search() преобразован
//в регулярное выражение с помощью конструктора RegExp. А если, например,  вовсе забыть указать второй аргумент, то будет
//произведена замена всех найденных совпадений на undefined

//Следующий интересующий нас метод это match().
//
//Он принимает в качестве аргумента регулярное выражение (или преобразовывает в него аргумент подобно предыдущим методам),
//а в качестве результата возвращает массив всех найденных соответствий.
//
//var myString = "У дедушки в деревне было 12 яблонь, 5 кустов смородины, 10 кур и 33 коровы";
//result = myString.match(/\d{2}/g);
//В данном примере мы записали в регулярное выражение обозначение цифры "\d", указали что ищем её двойное повторение "{2}"
// и включили флаг глобального поиска "g". В результате в переменной result окажется массив [12, 10, 33].
//
//Однако если флаг глобального поиска не будет указан, то в массив попадет только первое совпадение, оно запишется нулевым
//элементом. Остальными элементами массива будут подстроки, соответствующие всем подвыражениям, если таковые имеются.

//И последний из методов объекта String, позволяющих работать с регулярными выражениями, является split()
//
//Он разбивает строку на массив подстрок, используя в качестве разделителя содержимое аргумента, которое в том числе может
//быть и регулярным выражением. Например, использовав в качестве разделителя два слэша можно отделить в веб-адресе протокол
//от собственно наименования сайта:
//
//var myString = "http://www.example.com/download/pictures";
//result = myString.split(/\/{2}/g);
//Результатом данного выражения станет массив из двух элементов: "http:" и  "www.example.com/download/pictures"
//
//
//
//Таким же образом, например, можно разбить на массив строку состоящую из цифр:
//
//var myString = "1234567890987654321"
//result = myString.split(/\B/g);
//Используя в качестве разделителя определение символа, не являющегося границей слова (странное решение, но почему нет)
//получим в переменной result массив  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1].

//Во второй части урока мы более внимательно рассмотрим объект RegExp - его свойства, методы и конструктор.
//
//Начнем с конструктора. Как вы помните, конструктор, это метод, который принимает на вход некоторый аргумент, а на выходе
//создает объект необходимого вида.
//
//Конструктор RegExp может принимать на вход строку, содержимое которой будет преобразовано в регулярное выражение. В строке
//должно быть содержимое регулярного выражения, т.е. тот текст, который обычно находится между двух слэшей.
//
//var myPattern = new RegExp("q$");        // Создаем шаблон, находящий букву "q" в конце строки
//Также в конструктор можно передать второй, необязательный аргумент, в котором можно указать флаги. Например:
//
//var myPattern = new RegExp("q$","g");    // Создаем такой же шаблон, но добавляем флаг глобального поиска
//Важный момент! Если в тексте присутствует символ обратного слэша "\", то его необходимо предварять таким же символом
//(т.е. писать "\\"), поскольку, как мы помним, обратный слэш используется в регулярных выражениях для указания управляющих
//символов.

//Объект RegExp в JavaScript имеет следующие свойства:
//
//source - собственно текст регулярного выражения
//ignoreCase - логическое значение обозначающее наличие флага "i", доступно только для чтения
//global - логическое значение обозначающее наличие флага "g",  доступно только для чтения
//multiline - логическое значение обозначающее наличие флага "m",  доступно только для чтения
//lastIndex - счетчик, указывающий, с какой позиции в строке начинать поиск

//Методов у объекта RegExp всего два :
//
//exec(text) - выполнение поиска в строке, указанной в качестве параметра, возвращает массив найденных соответствий.
//test(text) - проверка соответствия регулярному выражению, возвращает true\false.
//
//Метод exec() выполняет регулярное выражение по отношению к строке-аргументу, результатом его работы является массив,
//в который попадают соответствия. Если соответствий не найдено, то результатом будет null. А если соответствие есть,
//то оно попадает в массив нулевым элементом, при этом свойство lastIndex объекта сместится на позицию, следующую
//непосредственно за найденной подстрокой. Давайте рассмотрим на примере :
//
//var myString = "This is just a test text";  // Задаем строку для поиска
//var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"
//
//result = myPattern.exec(myString);
//
////result будет равен "is" - первому совпадению шаблона, свойство lastIndex примет значение 4
//
//result = myPattern.exec(myString); //result == "is" - второму совпадению шаблона, lastIndex == 7
//result = myPattern.exec(myString); //result == "te" - третьему совпадению шаблона, lastIndex == 17
//result = myPattern.exec(myString); //result == "te" - четвертому совпадению шаблона, lastIndex == 22
//
//В этом примере мы четыре раза подряд вызываем метод exec(), каждый раз он сдвигает указатель начала поиска на позицию,
//следующую за найденным совпадением и присваивает переменной result само найденное совпадение.

//Метод test() выполняет регулярное выражение по отношению к строке-аргументу, результатом его работы является логическое
//значение - true если совпадение есть, и false если нет. Свойство lastIndex объекта также как и у метода exec() сместится
//на позицию, следующую непосредственно за найденной подстрокой.
//
//Важный момент! Если совпадение не найдено, то lastIndex будет смещен на позицию 0 и поиск можно будет начинать сначала.
//
//Давайте рассмотрим на таком же примере :
//
//var myString = "This is just a test text";  // Задаем строку для поиска
//var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"
//
//result = myPattern.test(myString);
//
//// result будет равен true, поскольку будет найдено первое совпадение, свойство lastIndex примет значение 4
//
//result = myPattern.test(myString); // result == true, lastIndex == 7
//result = myPattern.test(myString); // result == true, lastIndex == 17
//result = myPattern.test(myString); // result == true, lastIndex == 22
//result = myPattern.test(myString); // result == false, lastIndex == 0
//
//В этом примере мы пять раз подряд вызываем метод test(), каждый раз он сдвигает указатель начала поиска на позицию,
//следующую за найденным совпадением и присваивает переменной result булево значение - true если совпадение найдено и
//false - если нет. В последнем запуске совпадение не найдено, поэтому указатель lastIndex получает значение 0.

//В этом задании в нашу функцию testRegExp первым параметром передается случайная строка(переменная s), а вторым -
// случайная подстрока(переменная sub_s), которую нужно использовать в качестве шаблона регулярного выражения.
// Вам нужно вернуть из функции строку, в которой будут перечислены через запятую все совпадения шаблона с первой строкой.
//
//
//
//Sample Input 1:
//
//Andsirdaarrevarariarewbutovearrmararan
//ar
//Sample Output 1:
//
//ar,ar,ar,ar,ar,ar,ar

//function testRegExp(s, sub_s) {
//    var c = RegExp(sub_s,'g')
//    var result = s.match(c)
//    return result.join(',');
//
//}

//В данной теме мы разберем основы такого понятия как замыкания.
//
//Если в двух словах - замыкание это такая функция, которая была объявлена внутри другой функции.
//Есть еще одно условие - эта функция должна иметь доступ к переменным функции, внутри которой она была объявлена.
//
//Таким образом такая функция (замыкание) имеет доступ к данным внутри себя и внутри родительской функции.
//Также внутренняя функция может обращаться не только к переменным, но и к входным параметрам своей внешней функции

//Давайте рассмотрим практический пример.
//
//function greetPirate(pirateName) {            // Объявление родительской функции
//  var greeting = "Hello ";
//
//  function checkCaptain() {                   // Объявление замыкания
//    if (pirateName != "Jack Sparrow")
//      return greeting + pirateName;
//    else
//      return greeting + "CAPTAIN " + pirateName + "!";
//  }
//
//  return checkCaptain();
//}
//
//В этом примере мы написали функцию, которая выдает приветствие пирату - добавляет "Hello " к имени, которое подается на вход.
//Внутри этой функции мы создали замыкание (checkCaptain), которое проверяет входной параметр родительской функции - если
//имя пирата - "Jack Sparrow", то замыкание добавляет к имени слово "CAPTAIN" и для капитана Джека Воробья выводит персональное
//приветствие "Hello CAPTAIN Jack Sparrow!".
//
//В результате при вызове мы получим следующий результат:
//
//console.log(greetPirate("Mad Dog"));             // Выведет в консоль "Hello Mad Dog"
//console.log(greetPirate("Jack Sparrow"));        // Выведет в консоль "Hello CAPTAIN Jack Sparrow!"

//У замыканий есть два важных свойства.
//
//1. Замыкание может обращаться к переменным своей внешней функции даже после ее окончания выполнения.
//
//На практике это означает что даже после того как выполнение внешней функции завершено, внутренняя все еще может быть
// вызвана и имеет доступ к переменным внешней функции.
//
//Давайте рассмотрим пример:
//
//function pirate() {
//    var pirateName = "noname";
//    return {
//        getName: function() {
//            return pirateName;
//        },
//        setName: function(newName) {
//            pirateName = newName;
//        }
//    }
//}
//
//Мы описали функцию с двумя замыканиями: одно возвращает значение переменной из вызывающей функции, второе - изменяет его.
//Посмотрим, что получится при практическом использовании:
//
//var newPirate = pirate();
//console.log(newPirate.getName());    // Выводим текущее содержимое переменной - там изначальный "noname"
//newPirate.setName("Jack Sparrow");   //Изменяем значение переменной на "Jack Sparrow"
//console.log(newPirate.getName());    //Выводим текущее содержимое переменной - получаем "Jack Sparrow"
//
//В данном примере мы видим что замыкания получили доступ к переменной внешней функции после ее завершения.

//2. Замыкания хранят не содержимое переменных внешней функции, а ссылки на эти переменные.
//
//Давайте в этом контексте рассмотрим классический пример замыкания, описываемый в большинстве источников - счетчик.
//
//function makeCounter(initialValue) {
//  var currentState = initialValue;
//  return function () {
//    currentState = currentState + 1;
//    return currentState;
//  }
//}
//В данном случае мы описали функцию, внутри которой находится замыкание, увеличивающее каждый раз счетчик и возвращающее его.
//
//Давайте посмотрим, что получится если вызывать ее много раз подряд.
//
//var myCounter = makeCounter(5);  // Создаем экземпляр счетчика и устанавливаем его начальное значение = 5
//console.log(myCounter());        // В консоль будет выведено значение 6
//console.log(myCounter());        // В консоль будет выведено значение 7
//console.log(myCounter());        // В консоль будет выведено значение 8