//Для начала рассмотрим в общем - что же такое массив?
//
//Массив представляет из себя набор значений, доступ к которым осуществляется по их порядковому номеру. Значение в массиве
//называют "элементом массива" и обращаются к ним по их порядковому номеру, называемому "индексом".
//
//Массивы в JavaScript являются нетипизированными, т.е. позволяют внутри одного массива хранить элементы разных типов.
//Это могут  быть не только элементарные типы - строки, числа или символы, но также объекты и массивы, и даже массивы массивов.
//
//Массивы в JavaScript начинают отсчет индексов с нуля, для индексов используются 32-битные значения.
//
//Массивы в JavaScript являются динамическими, т.е.они могут увеличиваться или уменьшаться в размерах. Объявлять заранее
//фиксированные размеры при их создании, а также перераспределять память при изменении размеров, как это делается в
//некоторых других языках - не нужно.
//
//Массивы в JavaScript являются объектами!

//Для создания массива можно использовать три способа:
//
//Обычный способ создает массив через вызов конструктора Array():
//
//var myArray = new Array();   // объявление массива
//myArray[0] = "Иванов";        // добавление элемента
//myArray[1] = "Петров";
//myArray[2] = "Сидоров";
//myArray[3] = "Кузнецов";
//Также можно вызвать конструктор с числовым аргументом, указывающим количество элементов.
//
//var myArray = new Array(10);  // создание массива из 10 элементов
//Такую же операцию можно произвести сокращенным способом:
//var myArray = new Array("Иванов", "Петров", "Сидоров", "Кузнецов");
//И третий вариант - литеральный:
//var myArray = ["Иванов", "Петров", "Сидоров", "Кузнецов"];

//Чтение и запись, добавление и удаление элементов массива.
//
//Для доступа к элементам массива используется оператор [ ] (квадратные скобки).
//Слева от скобок должна быть ссылка на сам массив, внутри скобок должно находиться выражение, возвращающее неотрицательное
// целое значение.
//
//Как осуществляется запись в массив мы уже видели в предыдущем шаге:
//
//myArray[0] = "Иванов";   // запись 0-го элемента в массив myArray
//Чтение осуществляется аналогично :
//
//x = myArray[0]; // в результате в переменной x окажется значение первой ячейки массива - строковое значение "Иванов".

//Добавление элементов массива.
//
//Как мы уже видели, самый простой способ добавить элемент в массив - просто присвоить значение новым индексам. Например :
//
//myArray[4] = "Петров";
//Но мы также имеем на вооружении специальный метод - push().
//Например:
//
//
//myArray.push("Сидоров");
//добавит значение в конец массива, а команда
//
// myArray.push("Сидоров", 2);
//добавит сразу два элемента в конец массива - строку "Сидоров" и число "2" . Возвращаемое методом значение будет содержать
//длину (количество элементов) получившегося массива.
//
//Добавить элементы в конец массива также можно просто изменив свойство массива length :
//
//myArray.length = 5;
//В этом случае количество элементов в массиве увеличится, в конец массива добавятся пустые элементы.
//Конечно же, это свойство можно использовать и для получения информации о длине массива.
//
//Добавить элементы в начало массива можно с помощью метода unshift(). Например команда
//
//
//myArray.unshift("Сергеев", "Дмитриев")
//добавит в начало нашего массива два элемента со значениями  "Сергеев" и "Дмитриев", остальные элементы сместятся на
//позиции с более старшими индексами. Метод unshift() также возвращает длину получившегося массива. Таким образом выражение
//
//x = myArray.unshift("Сергеев", "Дмитриев")
//поместит два новых элемента в начало массива myArray и присвоит переменной х значение 7 (Потому что предыдущей командой мы
//установили размер массива - 5)

//var myArray = new Array(10);
//вывод
//[ <10 empty items> ]
//
//myArray.push(12)
//вывод
//[ <10 empty items>, 12 ]
//
//myArray.unshift(13, 15)
//вывод
//[ 13, 15, <10 empty items>, 12 ]
//
//myArray[6] = 10
//вывод
//[ 13, 15, <4 empty items>, 10, <5 empty items>, 12 ]

//myArray.length = 5;
//вывод
//[ 13, 15, <3 empty items> ] изменит количество елементов в массиве

//Обьеденение двух списков
//var a = [0, 1, 5, 3]
//var b = [3]
//
//console.log(a.concat(b))

//Удаление элементов массива.
//
//Удалить элемент массива можно с помощью оператора delete, как обычное свойство. Этот оператор рассматривали в уроке про
//объекты. В результате действия delete myArray[2]; значение 3-го элемента массива будет установлено в undefined, т.е. очищено,
//однако количество элементов в массиве не изменится, все остальные элементы останутся на своих местах.
//
//Для удаления элементов в конце массива можно прекрасно воспользоваться командой установки длины массива - изменение
//свойства length, например  - myArray.length = 4;
//
//Также удалить элемент в конце массива можно с помощью метода pop() (противоположного методу push), который уменьшает
//длину массива на 1 и возвращает значение удаленного элемента.
//
//Также есть метод shift() (противоположный методу unshift) который удаляет элемент в начале массива и
//сдвигает все элементы на 1 позицию в начало.

//Остальные методы класса Array.
//
//Array.join() - превращает все элементы массива в строки, объединяет их и возвращает получившуюся строку.
//Например если рассмотреть на примере из предыдущего шага - массиве из фамилий, команда myString = myArray.join(); поместит
//в строковую переменную myString значение "Иванов,Петров,Сидоров". По умолчанию для разделения используются запятые.
//В необязательном аргументе можно указать подстроку, которая будет использоваться для разделения значений. Например :
//команда myString = myArray.join("_"); поместит в строковую переменную myString значение "Иванов_Петров_Сидоров"
//
//Array.reverse() - меняет порядок следования элементов в массиве на обратный и возвращает уже переупорядоченный массив.
//Например, если рассмотреть объявленный ранее массив:
//
//var myArray = new Array("Иванов","Петров","Сидоров","Кузнецов");
//то команда console.log(myArray.reverse()); приведет к выводу в консоль значения ["Кузнецов", "Сидоров", "Петров", "Иванов"].
//
//Array.sort() - сортирует элементы в исходном массиве и возвращает отсортированный массив. Если метод использовать без
//аргумента (функции сортировки), то результат будет отсортирован в алфавитном порядке (в порядке следования символов
//в Unicode), путем преобразования всего, что возможно в строковый тип. Все, что привести к строкам невозможно -
//помещается в конец массива. Например, использование этого метода на массиве из предыдущего примера
//
//var myArray = new Array("Иванов", "Петров", "Сидоров", "Кузнецов");
//приведет к получению массива вот такого вида:  [ "Иванов", "Кузнецов", "Петров", "Сидоров"].
//
//В качестве аргумента в метод sort() можно передать функцию сравнения. Если результат, возвращаемый функцией сравнения,
//меньше 0, то сортировка поставит а перед b, и наоборот. Например, чтобы вывести в консоль значения , отсортированные
//в обратном алфавитном порядке мы можем воспользоваться вот такой командой:
//
//console.log(myArray.sort(function(a, b) {return b - a;}));
//
//Однако надо отметить, что такая функция сравнения сработает только если элементы нашего массива состоят из цифр. Если
// мы хотим изменить направление сортировки для строковых элементов, функция сравнения должна будет выглядеть чуть иначе,
// например вот так:
//
//console.log(myArray.sort(function(a, b) {return b.localeCompare(a);}));
//
//В данном случае мы использовали метод localeCompare() объекта String, позволяющий сравнивать объекты типа String или
//строковые литералы. Работает только если в списке все элементы строки или мы берем слайст со строками
//
//Array.concat() - возвращает (не изменяя исходного) новый массив с добавлением элементов, переданных в метод в качестве
//аргумента. Например,
//
// console.log(myArray.concat("Смит"));
//приведет к выводу в консоль  значения ["Иванов", "Кузнецов", "Петров", "Сидоров", "Смит"].
//
//Array.slice() - возвращает подмассив из массива, от первого до второго (но не включая его) из указанных аргументов.
//Например
//
//console.log(myArray.slice(1,3));
//
// приведет к выводу в консоль  значения ["Кузнецов", "Петров"], т.е. элементов с индексами 1 и 2.

//Следующий метод мы рассмотрим отдельным шагом по причине его универсальности и удобства.
//
//Array.splice() - универсальная функция, которая позволяет удалять элементы из массива и вставлять новые.
//
//В качестве аргумента в этот метод можно передать следующие данные:
//1 аргумент - позиция элемента, с которого начинается действие метода
//2 аргумент - количество удаляемых элементов, начиная со стартовой позиции, указанной в предыдущем аргументе. (Если второе
//значение не указано, будут удалены все элементы, начиная с первого аргумента).
//3 аргумент и последующие (любое количество) - элементы массива, которые будут добавлены начиная с позиции, указанной в
//первом аргументе.
//
//Важный момент - метод изменяет исходный массив, а возвращает массив удаленных элементов. Если ни один элемент не удален,
//возвращается пустое значение.
//
//В качестве примера рассмотрим работу этого метода на массиве
//
//var myArray = ["Иванов", "Петров", "Сидоров", "Кузнецов"];
//Получим такие результаты:
//
//// вернет ["Сидоров", "Кузнецов"], исходный массив станет равен ["Иванов", "Петров"]
//myArray.splice(2, 2);
//// вернет ["Петров", "Сидоров", "Кузнецов"], исходный массив превратится в ["Иванов"]
//myArray.splice(1);
// // вернет пустое значение [], в myArray добавится элемент ["Иванов", "Петров", "Смит", "Сидоров", "Кузнецов"]
//myArray.splice(2, 0, "Смит");
