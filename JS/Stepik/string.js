//Создание объекта String можно выполнить тремя способами:
//
//myString = 'my string' //создание с помощью строкового литерала, тип myString будет "string"
//myString = new String(object)  //создание объекта, тип myString будет "object"
//myString = String(object)   //тип myString будет "string"
//Как правило такие объекты создают неявно, строковым литералом: var myString = 'Some text';
//(строковым литералом называют любую последовательность символов, заключенную в любые кавычки)
//
//В строковом литерале вы можете использовать любые символы, а также escape-последовательности, если необходимо указать
//символ, который, например, нельзя набрать на клавиатуре. Выглядит это следующим образом:  var myString = '\u1234';
//где 1234 - номер знака в таблице юникода.
//
//
//Важный момент! При создании объекта с помощью литерала (текста в кавычках) вы получаете тип объекта "string",
//а при создании с помощью ключевого слова "new" вы получите тип "Object", этому объекту можно будет сразу напрямую
//назначать дополнительные свойства и методы.

//Свойства объекта "String"
//
//Хотя, конечно, слово "свойства" звучит слишком громко - стандартное свойство у него одно - длина. Обозначается оно словом
//".length" и возвращает количество символов в строке.
//
//var cat = "Cat";
//console.log(cat.length);
//В этом примере в консоль будет выведено значение длины строки - 3.

//Обращение по индексу
//Первый способ
//var cat = "Cat";
//console.log(cat.charAt(1));
//Этот код выведет в консоль символ с индексом 1 в строке - 'a

//Второй способ
//var cat = "Cat";
//console.log(cat[1]);
//этот код так же выведет а

//В JavaScript однажды созданную строку нельзя изменять, ее можно только считывать. Для изменения строки ее нужно полностью
//присваивать заново:
//
//var cat = "Cat";
//cat = cat.charAt(2) + cat.charAt(1) + cat.charAt(0);

//Слияние и разделение строк
//concat(string1, string2, ..., stringN) - объединяет строки
//split('разделитель') - разделяет строки на массив подстрок по указанному разделителю

//сoncat - объединение строк.

//var a = "первая строка";
//var b = " вторая строка";
//var c = " третья строка";
//result = a.concat(b , c); в начале всегда должна стоять переменная потом concat иначе работать не будет

//Split - разбиение строки на массив значений по разделителю.

//var myString = "cat,dog,bird";
//var myArray = myString.split(",");
//В результате в массиве myArray окажутся три элемента - ["cat", "dog", "bird"]

//У метода split есть еще один необязательный параметр - максимальное количество элементов в массиве. Все элементы больше
//указанного числа будут отброшены и в финальном массиве не появятся.
//
//var myString = "cat:dog:bird";
//var myArray = myString.split(":" , 2);
//В результате в массиве myArray окажутся только два элемента - ["cat", "dog"]

//Преобразование регистра
//
//toLowerCase() - преобразовывает все буквы в строке к нижнему регистру
//toUpperCase() -  преобразовывает все буквы в строке к верхнему регистру
//toLocaleLowerCase() -  преобразовывает все буквы в строке к нижнему регистру
//toLocaleUpperCase() -  преобразовывает все буквы в строке к верхнему регистру
//(Последние два метода имеют некоторые особенности для языков, правила которых противоречат соглашениям Unicode.)
//
//Поскольку синтаксис у всех этих методов одинаковый, в качестве примера рассмотрим только один.
//
//var catName = "Kitty";
//console.log (catName.toUpperCase());
//В результате выполнения этого кода в консоль будет выведено содержимое строки заглавными буквами - "KITTY"

//Возвращение части строки
//
//substring(indexA[, indexB]) - возвращает часть строки начиная с позиции indexA, но не включая indexB
//slice( indexA[, indexB] ) - возвращает часть строки начиная с позиции indexA, но не включая indexB
//substr(indexA[, length]) - возвращает часть строки начиная с позиции indexA, в количестве length
//replace(regexp, newSubString|function)  - возвращает новую строку после замен, указанных в regexp, или функцию,
//которая ее возвращает. Регулярные выражения - RegExp, мы с вами рассмотрим подробно в третьем модуле курса.
//
//Параметр в квадратных скобках является необязательным.
//
//В качестве примера разберем работу с методом  substring(indexA[, indexB])
//
//var myString = "Это просто строка!";
//console.log(myString.substring(4, 17));
//В результате в консоль будет выведен текст с 4 по 16-ю позиции - "просто строка"
//
//Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
//
//substring(indexA[, indexB]) - Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения
//усекаются до длины строки:
//
//alert( "testme".substring(-2) ); // "testme", -2 становится 0
//
//Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
//
//alert( "testme".substring(4, -1) ); // "test"
//// -1 становится 0 -> получили substring(4, 0)
//// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
//
//slice( indexA[, indexB] ) - Отрицательные значения отсчитываются от конца строки:
//
//alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
//alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
//
//Это гораздо более удобно, чем странная логика substring.
//
//Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
//
//Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: он и
//отрицательные аргументы поддерживает и работает наиболее очевидно.

//Поиск подстроки в строке
//
//
//indexOf(searchValue[, fromIndex]) - ищет подстроку searchValue начиная с позиции fromIndex (аргументы, указанные в
// квадратных скобках не являются обязательными).
//lastIndexOf(searchValue[, fromIndex]) - ищет последнюю подстроку  searchValue начиная с позиции fromIndex
//(внимание! поиск фактически будет в "обратную" сторону - т.е. первое вхождение от индекса fromIndex или конца строки
//в сторону начала строки)
//search(regExp) - возвращает индекс первого сопоставления с регулярным выражением внутри строки. В противном случае
//метод вернёт -1.
//match(regExp) - выдает массив всех совпадений с аргументом
//
//Для начала разберем работу с методом indexOf(searchValue[, fromIndex])
//
//var myString = "Это просто проверочная строка!";
//console.log(myString.indexOf("про", 0));

//В данном случае в консоль будет выведен номер позиции с которой начинается первая найденная подстрока  "про" - 4.
//"Это просто проверочная строка!";
//
//Однако, если мы укажем методу искать подстроку не с самого начала, а, например, с 5-й позиции:
//
//console.log(myString.indexOf("про", 5));
//То тогда результат будет "11" - позиция, с которой начинается второе вхождение подстроки "про".
//"Это просто проверочная строка!";
//
//Метод  lastIndexOf(searchValue[, fromIndex]) действует аналогично, но возвращает номер, с которого начинается
//последнее вхождение искомой подстроки. fromIndex обозначает место, с которого нужно начинать поиск по направлению
//к началу строки, его значение по-умолчанию - длина строки. В примере:
//
//var myString = "Это просто проверочная строка!";
//console.log(myString.lastIndexOf("про"));
//в консоль будет выведена цифра 11 - начало последнего вхождения подстроки "про".
//
//Методы  search(regExp) и match(regExp) здесь мы указали для полноты перечисления, их работу мы рассмотрим в
//следующем модуле, после освещения работы с регулярными выражениями.

//Преобразование типов
//
//fromCharCode(num1, num2,...,numN) - создает элементарную строку из значений символов Юникода
//Например, выражение  myString = String.fromCharCode(65, 66, 67);  присвоит переменной myString значение "ABC".
//
//
//toString() - возвращает элементарную строку вместо объекта String
//valueOf() - возвращает элементарную строку вместо объекта String, эквивалентно toString()
//В результате выполнения приведенного ниже кода в консоль будет выведено элементарное значение.
//
//myString = new String("Hello world");
//console.log(myString.valueOf());